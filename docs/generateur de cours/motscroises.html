<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Générateur de Prompt pour Mots Croisés</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Poppins', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .prompt-output::-webkit-scrollbar { width: 8px; height: 8px; }
      .prompt-output::-webkit-scrollbar-track { background: #e2e8f0; } /* slate-200 */
      .prompt-output::-webkit-scrollbar-thumb { background-color: #94a3b8; border-radius: 4px; } /* slate-400 */
      .prompt-output::-webkit-scrollbar-thumb:hover { background-color: #64748b; } /* slate-500 */
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out forwards;
      }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@19.1.0/client"
  }
}
</script>
</head>
<body class="bg-slate-50 text-slate-800 antialiased">
    <div id="root"></div>
    <script type="module">
    import React, { useState, useCallback } from 'react';
    import ReactDOM from 'react-dom/client';

    // --- CONSTANTES (inchangées) ---
    const GRID_SIZE = 50;
    const STOP_WORDS = new Set(['a', 'afin', 'ai', 'aie', 'aient', 'aies', 'ait', 'alors', 'apres', 'as', 'au', 'aucun', 'aucune', 'aujourd', 'aura', 'aurai', 'auraient', 'aurais', 'aurait', 'auras', 'aurez', 'auriez', 'aurions', 'aurons', 'auront', 'aussi', 'autre', 'autres', 'aux', 'avaient', 'avais', 'avait', 'avant', 'avec', 'avez', 'aviez', 'avions', 'avoir', 'avons', 'ayant', 'ayez', 'ayons', 'bon', 'car', 'ce', 'ceci', 'cela', 'celle', 'celles', 'celui', 'cependant', 'certain', 'certaine', 'certaines', 'certains', 'ces', 'cet', 'cette', 'ceux', 'chaque', 'ci', 'comme', 'comment', 'd', 'dans', 'de', 'deja', 'depuis', 'des', 'deux', 'devant', 'devrait', 'doit', 'donc', 'dont', 'du', 'elle', 'elles', 'en', 'encore', 'entre', 'est', 'et', 'etaient', 'etais', 'etait', 'etant', 'ete', 'etes', 'etiez', 'etions', 'etre', 'eu', 'eue', 'eues', 'eurent', 'eus', 'eusse', 'eussent', 'eusses', 'eussiez', 'eussions', 'eut', 'eux', 'faire', 'fais', 'faisaient', 'faisant', 'fait', 'faites', 'fois', 'font', 'furent', 'fus', 'fusse', 'fussent', 'fusses', 'fussiez', 'fussions', 'fut', 'haut', 'hors', 'hui', 'il', 'ils', 'j', 'je', 'l', 'la', 'le', 'les', 'leur', 'leurs', 'lui', 'm', 'ma', 'mais', 'me', 'meme', 'memes', 'mes', 'mien', 'mienne', 'miennes', 'miens', 'moi', 'moins', 'mon', 'mot', 'n', 'ne', 'ni', 'nom', 'non', 'nos', 'notre', 'notres', 'nous', 'on', 'ont', 'ou', 'par', 'parce', 'pas', 'pendant', 'personne', 'peu', 'peut', 'plus', 'plutot', 'pour', 'pourquoi', 'puis', 'qu', 'quand', 'que', 'quel', 'quelle', 'quelles', 'quels', 'qui', 's', 'sa', 'sans', 'se', 'sera', 'serai', 'seraient', 'serais', 'serait', 'seras', 'serez', 'seriez', 'serions', 'serons', 'seront', 'ses', 'si', 'sien', 'sienne', 'siennes', 'siens', 'soi', 'soient', 'sois', 'soit', 'sommes', 'son', 'sont', 'soyez', 'soyons', 'suis', 'sur', 't', 'ta', 'tandis', 'te', 'tel', 'telle', 'telles', 'tels', 'tes', 'toi', 'ton', 'tous', 'tout', 'toute', 'toutes', 'tres', 'tu', 'un', 'une', 'va', 'vais', 'vas', 'vers', 'voici', 'voila', 'vont', 'vos', 'votre', 'votres', 'vous', 'y']);

    // --- SERVICES (inchangés) ---
    function generateKeywordsLocally(courseText, wordCount, forcedWords) {
        const normalizeWord = (word) => word.toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        const uniqueForcedWords = new Set(forcedWords.split(/\s+/).map(w => w.trim().replace(/[^a-zA-Z]/g, '')).filter(w => w.length > 2).map(normalizeWord));
        const words = courseText.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z\s]/g, ' ').split(/\s+/);
        const wordFrequencies = {};
        for (const word of words) {
            if (word.length > 3 && !STOP_WORDS.has(word) && !uniqueForcedWords.has(normalizeWord(word))) {
                wordFrequencies[word] = (wordFrequencies[word] || 0) + 1;
            }
        }
        const sortedWords = Object.keys(wordFrequencies).sort((a, b) => wordFrequencies[b] - wordFrequencies[a]);
        const finalWordList = [...uniqueForcedWords];
        for (const word of sortedWords) {
            if (finalWordList.length >= wordCount) break;
            const normalized = normalizeWord(word);
            if (!finalWordList.includes(normalized)) { finalWordList.push(normalized); }
        }
        return finalWordList.map(word => ({ mot: word }));
    }
    const createGrid = (size) => Array(size).fill(null).map(() => Array(size).fill(null));
    function canPlaceWord(grid, word, row, col, direction) {
        if (row < 0 || col < 0) return false;
        if (direction === 'horizontal') {
            if (col + word.length > GRID_SIZE) return false;
            for (let i = 0; i < word.length; i++) {
                if (grid[row][col + i] && grid[row][col + i] !== word[i]) return false;
                if (!grid[row][col + i] && (grid[row - 1]?.[col + i] || grid[row + 1]?.[col + i])) return false;
            }
            if (grid[row]?.[col - 1] || grid[row]?.[col + word.length]) return false;
        } else {
            if (row + word.length > GRID_SIZE) return false;
            for (let i = 0; i < word.length; i++) {
                if (grid[row + i]?.[col] && grid[row + i][col] !== word[i]) return false;
                if (!grid[row + i]?.[col] && (grid[row + i]?.[col - 1] || grid[row + i]?.[col + 1])) return false;
            }
            if (grid[row - 1]?.[col] || grid[row + word.length]?.[col]) return false;
        }
        return true;
    }
    function finalizeGrid(grid, words) {
        let minRow = GRID_SIZE, minCol = GRID_SIZE, maxRow = 0, maxCol = 0;
        words.forEach(w => {
            if (w.direction === 'horizontal') {
                minRow = Math.min(minRow, w.row); maxRow = Math.max(maxRow, w.row);
                minCol = Math.min(minCol, w.col); maxCol = Math.max(maxCol, w.col + w.mot.length - 1);
            } else {
                minRow = Math.min(minRow, w.row); maxRow = Math.max(maxRow, w.row + w.mot.length - 1);
                minCol = Math.min(minCol, w.col); maxCol = Math.max(maxCol, w.col);
            }
        });
        const height = maxRow - minRow + 1;
        const width = maxCol - minCol + 1;
        if (height <= 1 && width <= 1) return null;
        const finalPlacedWords = words.map(w => ({ ...w, row: w.row - minRow, col: w.col - minCol, number: 0 }));
        let clueNumber = 1;
        const numberCoordinates = new Map();
        finalPlacedWords.sort((a, b) => a.row - b.row || a.col - b.col);
        for (const word of finalPlacedWords) {
            const key = `${word.row},${word.col}`;
            if (!numberCoordinates.has(key)) { numberCoordinates.set(key, clueNumber++); }
            word.number = numberCoordinates.get(key);
        }
        return { placedWords: finalPlacedWords, rows: height, cols: width };
    }
    function generateCrossword(words) {
        const sortedWords = [...words].sort((a, b) => b.mot.length - a.mot.length);
        let grid = createGrid(GRID_SIZE);
        const placedWords = [];
        if (sortedWords.length === 0) return null;
        const firstWord = sortedWords.shift();
        const startCol = Math.floor((GRID_SIZE - firstWord.mot.length) / 2);
        const startRow = Math.floor(GRID_SIZE / 2);
        for (let i = 0; i < firstWord.mot.length; i++) grid[startRow][startCol + i] = firstWord.mot[i];
        placedWords.push({ ...firstWord, row: startRow, col: startCol, direction: 'horizontal', number: 0 });
        for (const word of sortedWords) {
            let bestFit = null;
            let maxScore = -1;
            for (const placed of placedWords) {
                for (let i = 0; i < placed.mot.length; i++) {
                    for (let j = 0; j < word.mot.length; j++) {
                        if (placed.mot[i] === word.mot[j]) {
                            const newDirection = placed.direction === 'horizontal' ? 'vertical' : 'horizontal';
                            let newRow, newCol;
                            if (newDirection === 'vertical') { newRow = placed.row - j; newCol = placed.col + i; }
                            else { newRow = placed.row + i; newCol = placed.col - j; }
                            if (canPlaceWord(grid, word.mot, newRow, newCol, newDirection)) {
                                let score = 1; if (score > maxScore) { maxScore = score; bestFit = { word, row: newRow, col: newCol, direction: newDirection }; }
                            }
                        }
                    }
                }
            }
            if (bestFit) {
                const { word: wordToPlace, row, col, direction } = bestFit;
                for (let i = 0; i < wordToPlace.mot.length; i++) {
                    if (direction === 'horizontal') grid[row][col + i] = wordToPlace.mot[i];
                    else grid[row + i][col] = wordToPlace.mot[i];
                }
                placedWords.push({ ...wordToPlace, row, col, direction, number: 0 });
            }
        }
        return finalizeGrid(grid, placedWords);
    }

    function constructFinalPrompt(crosswordData, magicWord, backgroundImageUrl, courseText) {
        const dataString = JSON.stringify({
            rows: crosswordData.rows,
            cols: crosswordData.cols,
            placedWords: crosswordData.placedWords.map(({ mot, row, col, direction, number }) => ({ mot, row, col, direction, number }))
        }, null, 2);

        return `**Titre :** Prompt pour la création d'un jeu de mots croisés interactif en 2 étapes

**Objectif :** Générer le code pour une page web HTML autonome (un seul fichier) qui contient un jeu de mots croisés interactif. L'application doit être fonctionnelle sans aucune dépendance externe à installer.

---

### Contexte : Texte du Cours

L'IA doit utiliser le texte suivant comme unique source de vérité pour créer les définitions des mots.

\`\`\`
${courseText}
\`\`\`

---

### Étape 1 : Création des Définitions

Analysez le "Texte du Cours" fourni ci-dessus. Pour chaque mot présent dans la liste \`placedWords\` (dans les données JSON ci-dessous), rédigez une définition claire et concise (une phrase courte) en vous basant exclusivement sur le contexte du texte. Le style doit être adapté à des élèves.

---

### Étape 2 : Création du Jeu HTML

Utilisez les définitions que vous avez créées à l'étape 1, ainsi que les données de la grille ci-dessous, pour générer le code du jeu.

#### Données de la Grille

Intégrez ces données JSON directement dans le code JavaScript de la page.

\`\`\`json
${dataString}
\`\`\`

#### Fonctionnalités Requises

1.  **Grille Interactive :**
    * Affichez une grille basée sur les dimensions (\`rows\`, \`cols\`) et les mots placés (\`placedWords\`).
    * Chaque case de lettre doit être un champ de saisie acceptant un seul caractère.
    * Les cases non utilisées doivent être visuellement distinctes et inactives (par exemple, colorées en noir).
    * Affichez le numéro de l'indice (\`number\`) dans la première case de chaque mot.

2.  **Listes d'Indices :**
    * Affichez deux listes de définitions (celles créées à l'étape 1) : "HORIZONTAL" et "VERTICAL". Chaque indice doit être préfixé par son numéro.

3.  **Logique de Jeu :**
    * **Saisie :** L'utilisateur peut taper des lettres dans les cases. La navigation au clavier (touches fléchées) est fortement souhaitée.
    * **Vérification :** Un bouton "Vérifier" doit comparer les réponses de l'utilisateur avec la solution (\`mot\` dans \`placedWords\`). Les lettres correctes doivent être mises en évidence (ex: fond vert), les incorrectes aussi (ex: fond rouge).
    * **Récompense :** Quand la grille est entièrement et correctement remplie, un message de félicitations doit apparaître et révéler le mot magique.

### Mot Magique et Personnalisation

* **Mot Magique :** Le mot à révéler à la fin est : **"${magicWord || 'BRAVO'}"**
* **Image de fond (Optionnel) :** Si une URL est fournie ci-dessous, utilisez-la comme image de fond pour la page. Si elle est vide, utilisez une couleur ou un dégradé simple.
    * URL : ${backgroundImageUrl ? `"${backgroundImageUrl}"` : "Aucune"}

---

Produisez le code complet pour ce fichier HTML unique et autonome. Vous pouvez utiliser du JavaScript vanilla ou une bibliothèque légère comme React ou Vue via un CDN, mais le résultat final doit être un seul fichier.
`;
    }

    // --- ICON COMPONENTS ---
    const Spinner = () => React.createElement('svg', { className: "animate-spin h-5 w-5 text-white", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, React.createElement('circle', { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), React.createElement('path', { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
    const ClipboardIcon = ({ className = "w-5 h-5" }) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:2, stroke:"currentColor" }, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" }));
    const CheckIcon = ({ className = "w-5 h-5" }) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:3, stroke:"currentColor" }, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M5 13l4 4L19 7" }));
    const SparklesIcon = ({ className = "w-6 h-6" }) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:1.5, stroke:"currentColor" }, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.5 21.75l-.398-1.188a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.188-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.188a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.188.398a2.25 2.25 0 00-1.423 1.423z" }));
    const ArrowLeftIcon = ({ className="w-5 h-5"}) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:2, stroke:"currentColor"}, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M10 19l-7-7m0 0l7-7m-7 7h18" }));
    const BookOpenIcon = ({ className="w-5 h-5"}) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:1.5, stroke:"currentColor"}, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25" }));
    const PuzzleIcon = ({ className="w-5 h-5"}) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:1.5, stroke:"currentColor"}, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M14.25 6.75a.75.75 0 01.75-.75h.01a.75.75 0 01.75.75v.01a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75V6.75zM14.25 12a.75.75 0 01.75-.75h.01a.75.75 0 01.75.75v.01a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-.01zM14.25 17.25a.75.75 0 01.75-.75h.01a.75.75 0 01.75.75v.01a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-.01zM4.5 12a2.25 2.25 0 002.25 2.25H9a2.25 2.25 0 002.25-2.25v-1.5A2.25 2.25 0 009 8.25H6.75A2.25 2.25 0 004.5 10.5v1.5zm15-1.5a2.25 2.25 0 01-2.25-2.25H15a2.25 2.25 0 01-2.25-2.25V5.25A2.25 2.25 0 0112.75 3H15a2.25 2.25 0 012.25 2.25v1.5a2.25 2.25 0 012.25 2.25v1.5a2.25 2.25 0 01-2.25 2.25h-1.5zM4.5 17.25a2.25 2.25 0 002.25 2.25H9a2.25 2.25 0 002.25-2.25v-1.5A2.25 2.25 0 009 15.75H6.75a2.25 2.25 0 00-2.25 2.25v1.5z" }));
    const WandIcon = ({ className="w-5 h-5"}) => React.createElement('svg', { xmlns:"http://www.w3.org/2000/svg", className:className, fill:"none", viewBox:"0 0 24 24", strokeWidth:1.5, stroke:"currentColor"}, React.createElement('path', { strokeLinecap:"round", strokeLinejoin:"round", d:"M9.75 3.104v5.714a2.25 2.25 0 01-.659 1.591L5 14.5M9.75 3.104c.245-.02.49-.034.742-.034h3.014c.252 0 .5-.014.742.034M3 13.5h18M3 13.5a2.25 2.25 0 00-2.25 2.25v1.5a2.25 2.25 0 002.25 2.25h18a2.25 2.25 0 002.25-2.25v-1.5a2.25 2.25 0 00-2.25-2.25M19.5 14.5l-4.102-4.102a2.25 2.25 0 00-1.591-.659V3.104M14.25 3.104c-.245-.02-.49-.034-.742-.034h-3.014c-.252 0-.5.014-.742.034" }));


    // --- UI COMPONENTS ---
    const Card = ({ children, className = '' }) => React.createElement('div', { className: `bg-white/80 backdrop-blur-sm rounded-2xl shadow-lg border border-slate-200/80 ${className}` }, children);
    const SectionTitle = ({ icon, title, subtitle }) => React.createElement('div', { className: 'flex items-start space-x-4' }, React.createElement('div', { className: 'bg-sky-100 p-3 rounded-xl border border-sky-200' }, icon), React.createElement('div', null, React.createElement('h2', { className: 'text-xl font-bold text-slate-800' }, title), React.createElement('p', { className: 'text-sm text-slate-500' }, subtitle)));
    const Button = ({ children, isLoading = false, icon, className = '', ...props }) => React.createElement('button', { ...props, disabled: isLoading || props.disabled, className: `w-full flex items-center justify-center bg-sky-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-sky-700 disabled:bg-sky-300 disabled:cursor-not-allowed transition-all duration-300 ease-in-out text-lg shadow-md hover:shadow-sky-300 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-sky-500 ${className}` }, isLoading ? React.createElement(Spinner) : React.createElement(React.Fragment, null, icon && React.createElement('span', { className: "mr-2 -ml-1" }, icon), children));
    const PromptOutput = ({ prompt }) => {
        const [copySuccess, setCopySuccess] = useState(false);
        const copyToClipboard = () => { if (!prompt) return; navigator.clipboard.writeText(prompt).then(() => { setCopySuccess(true); setTimeout(() => setCopySuccess(false), 2500); }).catch(err => { console.error('Erreur de copie: ', err); }); };
        return React.createElement('div', { className: "relative" }, React.createElement('pre', { className: "bg-slate-800 text-slate-200 p-4 rounded-lg overflow-x-auto max-h-[400px] text-sm prompt-output border border-slate-700" }, React.createElement('code', null, prompt)), React.createElement('button', { onClick: copyToClipboard, className: `absolute top-3 right-3 p-2 rounded-lg transition-colors text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800 focus:ring-sky-500 ${copySuccess ? 'bg-green-500 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`, 'aria-label': copySuccess ? "Copié !" : "Copier le prompt" }, copySuccess ? React.createElement(CheckIcon) : React.createElement(ClipboardIcon)));
    };

    // --- MAIN APP COMPONENT ---
    const App = () => {
        const DEFAULT_TEXT = "Un écosystème est un ensemble d'organismes vivants qui interagissent entre eux et avec leur milieu. La photosynthèse est le processus des plantes pour utiliser la lumière du soleil. La biodiversité est la variété de la vie.";
        const [courseText, setCourseText] = useState(DEFAULT_TEXT);
        const [wordCount, setWordCount] = useState(8);
        const [forcedWords, setForcedWords] = useState('');
        const [magicWord, setMagicWord] = useState('VICTOIRE');
        const [imageUrl, setImageUrl] = useState('');
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);
        const [generatedPrompt, setGeneratedPrompt] = useState('');

        const handleGeneratePrompt = useCallback(() => {
            if (!courseText.trim() || !magicWord.trim()) { setError("Veuillez fournir un texte de base et un mot magique."); return; }
            setIsLoading(true); setError(null); setGeneratedPrompt('');
            setTimeout(() => {
                try {
                    const wordsOnly = generateKeywordsLocally(courseText, wordCount, forcedWords);
                    if (wordsOnly.length < Math.min(4, wordCount)) {
                        setError(`Seulement ${wordsOnly.length} mots uniques sur les ${wordCount} demandés ont été trouvés. Essayez avec un texte plus riche ou moins de mots.`);
                        setIsLoading(false); return;
                    }
                    const data = generateCrossword(wordsOnly);
                    if (!data || data.placedWords.length < Math.min(3, wordsOnly.length)) {
                        setError("Impossible de générer une grille cohérente. Essayez avec d'autres mots ou modifiez le nombre de mots.");
                    } else {
                        const finalPrompt = constructFinalPrompt(data, magicWord, imageUrl, courseText);
                        setGeneratedPrompt(finalPrompt);
                    }
                } catch (e) {
                    console.error(e);
                    setError("Une erreur de traitement est survenue. Veuillez réessayer.");
                } finally {
                    setIsLoading(false);
                }
            }, 50);
        }, [courseText, wordCount, magicWord, imageUrl, forcedWords]);
        
        return React.createElement('div', { className: "min-h-screen bg-slate-50 font-sans p-4 sm:p-6 lg:p-8" },
            React.createElement('div', { className: "max-w-6xl mx-auto space-y-8" },
                React.createElement('a', { href: "exercices2.html", className: "absolute top-4 left-4 flex items-center gap-2 text-slate-500 hover:text-sky-600 font-semibold transition-colors" },
                    React.createElement(ArrowLeftIcon, { className: 'w-5 h-5'}), 'Retour'
                ),
                React.createElement('header', { className: "text-center pt-10" },
                    React.createElement('div', {className: 'inline-block bg-sky-100 p-4 rounded-full mb-4 ring-8 ring-white/50'}, 
                        React.createElement(PuzzleIcon, {className: 'w-12 h-12 text-sky-600'})
                    ),
                    React.createElement('h1', { className: "text-4xl sm:text-5xl font-extrabold text-slate-900 tracking-tight" }, "Créez votre Jeu de Mots Croisés"),
                    React.createElement('p', { className: "mt-4 text-lg text-slate-600 max-w-2xl mx-auto" }, "Transformez n'importe quel texte en un jeu de mots croisés interactif. C'est simple et rapide !")
                ),
                React.createElement('main', null,
                    React.createElement(Card, { className: "p-6 sm:p-8" },
                        React.createElement('fieldset', { disabled: isLoading, className: "space-y-10" },
                            React.createElement('div', { className: "grid grid-cols-1 lg:grid-cols-2 gap-10" },
                                React.createElement('div', { className: "space-y-8" },
                                    React.createElement(SectionTitle, { icon: React.createElement(BookOpenIcon, {className: 'text-sky-600'}), title: 'Étape 1 : Fournissez le contenu', subtitle: 'Indiquez le texte qui servira à créer les définitions du jeu.'}),
                                    React.createElement('div', null,
                                        React.createElement('label', { htmlFor: "course-text", className: "block text-md font-semibold mb-2 text-slate-700" }, "Votre texte de référence"),
                                        React.createElement('textarea', { id: "course-text", className: "w-full p-3 h-48 bg-white border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition shadow-sm", value: courseText, onChange: (e) => setCourseText(e.target.value), placeholder: "Collez votre texte de référence ici..." })
                                    ),
                                    React.createElement('div', null,
                                        React.createElement('label', { htmlFor: "forced-words", className: "block text-md font-semibold mb-2 text-slate-700" }, "Mots à inclure absolument", React.createElement('span', { className: "text-sm font-normal text-slate-500" }, " (Optionnel)")),
                                        React.createElement('textarea', { id: "forced-words", className: "w-full p-3 h-28 bg-white border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition shadow-sm", value: forcedWords, onChange: (e) => setForcedWords(e.target.value), placeholder: "Écrivez ici les mots que vous voulez voir dans la grille, séparés par un espace." })
                                    )
                                ),
                                React.createElement('div', { className: "space-y-8" },
                                    React.createElement(SectionTitle, { icon: React.createElement(WandIcon, {className: 'text-sky-600'}), title: 'Étape 2 : Personnalisez le jeu', subtitle: 'Réglez les détails pour rendre votre jeu unique.'}),
                                    React.createElement('div', null,
                                        React.createElement('label', { htmlFor: "word-count", className: "block text-md font-semibold mb-2 text-slate-700" }, "Combien de mots dans la grille ?"),
                                        React.createElement('input', { id: "word-count", type: "number", min: "5", max: "20", className: "w-full p-3 bg-white border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition shadow-sm", value: wordCount, onChange: (e) => setWordCount(Math.max(5, Math.min(20, Number(e.target.value)))) })
                                    ),
                                    React.createElement('div', null,
                                        React.createElement('label', { htmlFor: "magic-word", className: "block text-md font-semibold mb-2 text-slate-700" }, "Le mot magique (récompense)"),
                                        React.createElement('input', { id: "magic-word", type: "text", className: "w-full p-3 bg-white border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition shadow-sm", value: magicWord, onChange: (e) => setMagicWord(e.target.value), placeholder: "Ex: BRAVO, CHAMPION..." })
                                    ),
                                    React.createElement('div', null,
                                        React.createElement('label', { htmlFor: "image-url", className: "block text-md font-semibold mb-2 text-slate-700" }, "Image de fond ", React.createElement('span', { className: "text-sm font-normal text-slate-500" }, "(URL, Optionnel)")),
                                        React.createElement('input', { id: "image-url", type: "url", className: "w-full p-3 bg-white border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition shadow-sm", value: imageUrl, onChange: (e) => setImageUrl(e.target.value), placeholder: "https://exemple.com/image.jpg" })
                                    )
                                )
                            ),
                            React.createElement('div', { className: "mt-10 border-t border-slate-200 pt-8" },
                                React.createElement(Button, { onClick: handleGeneratePrompt, isLoading: isLoading, icon: React.createElement(SparklesIcon, { className: "w-6 h-6" }) }, isLoading ? 'Création en cours...' : 'Générer le Prompt')
                            ),
                            error && React.createElement('div', { className: "mt-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md", role: "alert" },
                                React.createElement('p', { className: "font-bold" }, "Attention !"),
                                React.createElement('p', null, error)
                            )
                        )
                    ),
                    generatedPrompt && !isLoading && React.createElement('div', { className: "animate-fade-in mt-10" },
                        React.createElement(Card, { className: "p-6 sm:p-8" },
                            React.createElement(SectionTitle, { icon: React.createElement(SparklesIcon, {className: 'text-sky-600'}), title: 'Étape 3 : Lancez la magie !', subtitle: "Copiez ce prompt et donnez-le à une IA. Elle créera votre jeu instantanément !"}),
                            React.createElement('div', { className: 'mt-6' },
                                React.createElement(PromptOutput, { prompt: generatedPrompt })
                            )
                        )
                    ),
                    isLoading && !generatedPrompt && React.createElement(Card, { className: "p-6 sm:p-8 text-center mt-10" },
                        React.createElement('div', { className: "flex justify-center items-center gap-4" }, React.createElement(Spinner), React.createElement('p', { className: "text-slate-500 text-lg" }, "Analyse du texte et construction de la grille...")))
                )
            )
        );
    };

    // --- RENDER APP ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(React.createElement(React.StrictMode, null, React.createElement(App)));

    </script>
</body>
</html>